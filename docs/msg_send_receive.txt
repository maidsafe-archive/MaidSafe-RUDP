Written 2014-8-26 by ned. May now be out of date.

I'll quickly review how RUDP sends messages after ManagedConnections::Send() as it will be useful. Message sending involves Connection::StartSending() encrypting the message with the peer public key in the same thread as the sending thread and adding it as a string to the send queue. The send queue is pumped by the Connection strand into Socket::AsyncWrite at best speed, though with a totally unnecessary memory copy into an internal buffer just to prepend a 3 byte length. Socket::AsyncWrite, despite its name, actually is mostly synchronous and will return immediately only if the send buffers would not overflow, blocking the Connection strand otherwise. Messages are sent by filling up the send buffers with memcpy in Sender each of which is currently 8Kb, and there are the send sliding window number of them which is currently 64, so that makes the total send buffer space 512Kb - note that due to headers, actually slightly more than 8Kb is sent. As ack messages come in, the sliding window is advanced by Sender and more 8Kb chunks sent with unacked messages resent after a timeout. Note that Sender uses a synchronous ASIO API (which lives in Multiplexer, which itself does another pointless memcpy of the packet onto the stack to prepend another header) to send the UDP packet and therefore effectively the Connection strand is slept by the kernel if you try to send more than 512Kb, yet Connection will accept as many messages as you give it so it just keeps adding strings to its send queue even if the network is congested.

Similarly for message receipt, one is notified that a message has arrived by the callback you passed to ManagedConnections::Bootstrap() being invoked. This is implemented by Connection::StartReadSize() being called by Connection::HandleConnect(), and this calls Socket::AsyncRead() to have it fill a 3 byte buffer in Connection with incoming packets. These 3 bytes are of course for the subsequent message length, so the Connection::StartReadData() callback which is invoked in the Connection strand after the 3 byte read allocates enough memory for the incoming message and invokes a Socket::AsyncRead() on that buffer. Socket::AsyncRead() works by registering the buffer internally with Socket::StartRead() - if one is already registered, it blocks until the current buffer is retired - and the current buffer's completion handler is called as data becomes available which is performed by Socket::ProcessRead().

How that data becomes available requires me to start from the other end, so Multiplexer::AsyncDispatch() starts an async read from the socket with ASIO, and when a packet arrives it is inspected by Socket to decide what kind of packet it is, calling the appropriate HandleXXX function in Socket. In HandleData(), Socket calls Receiver::HandleData() which memcpys packets as they arrive into its sliding window - interestingly, this is kept as a std::deque<> which wouldn't be my first choice of container for this role, but it's probably okay. Anyway, Socket::ProcessRead() is regularly pumped, and it memcpys as much data as there are contiguous packets at the front into the buffer supplied to Socket::StartRead(), deleting the read packets from the front of the std::deque, and once the buffer passed to Socket::StartRead() is full it invokes its completion handler, retires the buffer and unblocks whatever is waiting on the next read operation.

